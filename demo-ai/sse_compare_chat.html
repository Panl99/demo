<!DOCTYPE html>
<html lang="zh-CN" :data-theme="currentTheme">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DeepSeek Chat</title>
    <script src="https://cdn.bootcdn.net/ajax/libs/vue/3.5.13/vue.global.min.js"></script>
    <script src="https://cdn.bootcdn.net/ajax/libs/marked/15.0.6/marked.min.js"></script>
    <link href="https://cdn.bootcdn.net/ajax/libs/daisyui/4.12.23/full.min.css" rel="stylesheet" type="text/css"/>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        [data-theme='dark'] ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        [data-theme='dark'] ::-webkit-scrollbar-track {
            background: #2C2C2C;
            border-radius: 4px;
        }

        [data-theme='dark'] ::-webkit-scrollbar-thumb {
            background: #424242;
            border-radius: 4px;
        }

        [data-theme='dark'] ::-webkit-scrollbar-thumb:hover {
            background: #505050;
        }
    </style>
</head>
<body class="min-h-screen bg-base-100 transition-colors duration-200">
<div id="app">

    <main class="h-[calc(100vh-16rem)] container mx-auto px-4 py-2 overflow-hidden">
        <div class="flex gap-4 h-full">
            <!-- å·¦ä¾§æ¨ç†è¿‡ç¨‹å’Œç­”æ¡ˆåŒºåŸŸ -->
            <div class="w-1/2 flex flex-col">
                <!-- å¤´éƒ¨åŒºåŸŸ -->
                <div class="mb-8">
                    <!-- æ ‡é¢˜è¡Œï¼šå›¾æ ‡å’Œé—®å€™è¯­ -->
                    <div class="flex items-center gap-4 mb-4">
                        <h1 class="text-xl">è°ƒç”¨å®˜æ–¹DeepSeekæ¥å£ğŸ‘‡:</h1>
                    </div>
                </div>

                <!-- æ¨ç†è¿‡ç¨‹ -->
                <div>
                    <h2 class="text-lg font-bold mb-2">æ¨ç†è¿‡ç¨‹</h2>
                    <div class="bg-base-200 rounded-lg p-4">
                        <div ref="reasoningRef" class="min-h-[100px] max-h-[200px] overflow-y-auto"> <!--whitespace-pre-wrap-->
                            {{ reasoningChain || 'æš‚æ— æ¨ç†è¿‡ç¨‹' }}
                        </div>
                    </div>
                </div>

                <!-- æœ€ç»ˆç­”æ¡ˆ -->
                <div>
                    <h2 class="text-lg font-bold mb-2">æœ€ç»ˆç­”æ¡ˆ</h2>
                    <div class="bg-base-200 rounded-lg p-4">
                        <div ref="answerRef"
                             class="min-h-[150px] max-h-[200px] overflow-y-auto prose dark:prose-invert max-w-none"
                             v-html="finalAnswer || 'æš‚æ— ç­”æ¡ˆ'">
                        </div>
                    </div>
                </div>

            </div>

            <!-- å³ä¾§æ¨ç†è¿‡ç¨‹å’Œç­”æ¡ˆåŒºåŸŸ -->
            <div class="w-1/2 flex flex-col">
                <!-- å¤´éƒ¨åŒºåŸŸ -->
                <div class="mb-8">
                    <!-- æ ‡é¢˜è¡Œï¼šå›¾æ ‡å’Œé—®å€™è¯­ -->
                    <div class="flex items-center gap-4 mb-4">
                        <h1 class="text-xl">è°ƒç”¨æœ¬åœ°éƒ¨ç½²DeepSeekæ¥å£ğŸ‘‡:</h1>
                    </div>
                </div>

                <!-- æ¨ç†è¿‡ç¨‹ -->
                <div>
                    <h2 class="text-lg font-bold mb-2">æ¨ç†è¿‡ç¨‹</h2>
                    <div class="bg-base-200 rounded-lg p-4">
                        <div ref="reasoningRef" class="min-h-[100px] max-h-[200px] overflow-y-auto"> <!--whitespace-pre-wrap-->
                            {{ reasoningChain2 || 'æš‚æ— æ¨ç†è¿‡ç¨‹' }}
                        </div>
                    </div>
                </div>

                <!-- æœ€ç»ˆç­”æ¡ˆ -->
                <div>
                    <h2 class="text-lg font-bold mb-2">æœ€ç»ˆç­”æ¡ˆ</h2>
                    <div class="bg-base-200 rounded-lg p-4">
                        <div ref="answerRef"
                             class="min-h-[150px] max-h-[200px] overflow-y-auto prose dark:prose-invert max-w-none"
                             v-html="finalAnswer2 || 'æš‚æ— ç­”æ¡ˆ'">
                        </div>
                    </div>
                </div>
            </div>


        </div>
    </main>
    <!-- èŠå¤©åŒºåŸŸ -->
    <div class="space-y-6">
        <!-- è¾“å…¥åŒºåŸŸ -->
        <div class="h-[calc(100vh-36rem)] container mx-auto px-4 py-2 overflow-hidden">
                    <textarea
                            v-model="userInput"
                            class="w-full h-16 p-4 rounded-lg bg-base-200 resize-none focus:outline-none"
                            placeholder="ç»™ DeepSeek å‘é€æ¶ˆæ¯"
                    ></textarea>

            <div class="flex gap-2 mt-2">
                <button
                        @click="connectAll"
                        :disabled="isConnected"
                        class="btn btn-primary"
                >
                    æäº¤
                </button>
                <button
                        @click="disconnectAll"
                        :disabled="!isConnected"
                        class="btn btn-error"
                >
                    æ–­å¼€
                </button>
                <button
                        @click="clearMessages"
                        class="btn btn-ghost"
                >
                    æ¸…ç©º
                </button>
            </div>
        </div>
    </div>

</div>

<script>
    const {createApp, ref, computed, watch, nextTick} = Vue

    createApp({
        setup() {
            const userInput = ref('')
            const messages = ref([])
            const isConnected = ref(false)
            const isInThinkTag = ref(false)
            let eventSource = null
            const reasoningRef = ref(null)
            const answerRef = ref(null)

            // å³ä¾§
            const messages2 = ref([])
            const isInThinkTag2 = ref(false)
            let eventSource2 = null
            const reasoningRef2 = ref(null)
            const answerRef2 = ref(null)

            const reasoningChain = computed(() => {
                return messages.value
                    .filter(m => m.parsed?.reasoning_content)
                    .map(m => m.parsed.reasoning_content)
                    .join('')
            })

            const finalAnswer = computed(() => {
                const rawContent = messages.value
                    .filter(m => m.parsed?.content)
                    .map(m => m.parsed.content)
                    .join('')
                return marked.parse(rawContent)
            })

            // å³ä¾§
            const reasoningChain2 = computed(() => {
                return messages2.value
                    .filter(m => m.parsed?.reasoning_content)
                    .map(m => m.parsed.reasoning_content)
                    .join('')
            })
            const finalAnswer2 = computed(() => {
                const rawContent = messages2.value
                    .filter(m => m.parsed?.content)
                    .map(m => m.parsed.content)
                    .join('')
                return marked.parse(rawContent)
            })

            const scrollToBottom = (element) => {
                if (element) {
                    const scrollContainer = element
                    if (scrollContainer) {
                        scrollContainer.scrollTop = scrollContainer.scrollHeight
                    }
                }
            }

            watch(() => [messages.value.length, reasoningChain.value, finalAnswer.value, messages2.value.length, reasoningChain2.value, finalAnswer2.value], () => {
                nextTick(() => {
                    if (reasoningRef.value) {
                        scrollToBottom(reasoningRef.value)
                    }
                    if (answerRef.value) {
                        scrollToBottom(answerRef.value)
                    }
                    if (reasoningRef2.value) {
                        scrollToBottom(reasoningRef2.value)
                    }
                    if (answerRef2.value) {
                        scrollToBottom(answerRef2.value)
                    }
                })
            }, {deep: true})

            const parseSSEData = (data) => {
                try {
                    const parsed = JSON.parse(data)
                    const directReasoning = parsed.choices?.[0]?.delta?.reasoning_content
                    if (directReasoning) {
                        return {
                            id: parsed.id,
                            created: parsed.created,
                            model: parsed.model,
                            reasoning_content: directReasoning,
                            content: parsed.choices?.[0]?.delta?.content || ''
                        }
                    }

                    const content = parsed.choices?.[0]?.delta?.content || ''

                    if (content.includes('<think>')) {
                        isInThinkTag.value = true
                        const startIndex = content.indexOf('<think>') + '<think>'.length
                        return {
                            id: parsed.id,
                            created: parsed.created,
                            model: parsed.model,
                            reasoning_content: content.substring(startIndex),
                            content: content.substring(0, content.indexOf('<think>'))
                        }
                    }

                    if (content.includes('</think>')) {
                        isInThinkTag.value = false
                        const endIndex = content.indexOf('</think>')
                        return {
                            id: parsed.id,
                            created: parsed.created,
                            model: parsed.model,
                            reasoning_content: content.substring(0, endIndex),
                            content: content.substring(endIndex + '</think>'.length)
                        }
                    }

                    return {
                        id: parsed.id,
                        created: parsed.created,
                        model: parsed.model,
                        reasoning_content: isInThinkTag.value ? content : '',
                        content: isInThinkTag.value ? '' : content
                    }
                } catch (e) {
                    console.error('è§£æJSONå¤±è´¥:', e)
                    return null
                }
            }

            // å³ä¾§
            const parseSSEData2 = (data) => {
                try {
                    const parsed = JSON.parse(data)
                    const directReasoning = parsed.choices?.[0]?.delta?.reasoning_content
                    if (directReasoning) {
                        return {
                            id: parsed.id,
                            created: parsed.created,
                            model: parsed.model,
                            reasoning_content: directReasoning,
                            content: parsed.choices?.[0]?.delta?.content || ''
                        }
                    }

                    const content = parsed.choices?.[0]?.delta?.content || ''

                    if (content.includes('<think>')) {
                        isInThinkTag2.value = true
                        const startIndex = content.indexOf('<think>') + '<think>'.length
                        return {
                            id: parsed.id,
                            created: parsed.created,
                            model: parsed.model,
                            reasoning_content: content.substring(startIndex),
                            content: content.substring(0, content.indexOf('<think>'))
                        }
                    }

                    if (content.includes('</think>')) {
                        isInThinkTag2.value = false
                        const endIndex = content.indexOf('</think>')
                        return {
                            id: parsed.id,
                            created: parsed.created,
                            model: parsed.model,
                            reasoning_content: content.substring(0, endIndex),
                            content: content.substring(endIndex + '</think>'.length)
                        }
                    }

                    return {
                        id: parsed.id,
                        created: parsed.created,
                        model: parsed.model,
                        reasoning_content: isInThinkTag2.value ? content : '',
                        content: isInThinkTag2.value ? '' : content
                    }
                } catch (e) {
                    console.error('è§£æJSONå¤±è´¥:', e)
                    return null
                }
            }

            const connect = () => {
                if (eventSource) {
                    eventSource.close()
                }

                if (!userInput.value.trim()) {
                    alert('è¯·è¾“å…¥æ¶ˆæ¯')
                    return
                }

                clearMessages()

                try {
                    const baseUrl = 'http://localhost:8080/chat'
                    const url = `${baseUrl}?prompt=${encodeURIComponent(userInput.value.trim())}`

                    eventSource = new EventSource(url)
                    isConnected.value = true

                    eventSource.onmessage = (event) => {
                        const parsed = parseSSEData(event.data)
                        messages.value.push({
                            time: new Date().toLocaleTimeString(),
                            data: event.data,
                            parsed: parsed
                        })
                    }

                    eventSource.onerror = (error) => {
                        console.error('SSE Error:', error)
                        disconnect()
                    }
                } catch (error) {
                    console.error('Connection Error:', error)
                    disconnect()
                }
            }

            // å³ä¾§
            const connect2 = () => {
                if (eventSource2) {
                    eventSource2.close()
                }

                if (!userInput.value.trim()) {
                    alert('è¯·è¾“å…¥æ¶ˆæ¯')
                    return
                }

                clearMessages()

                try {
                    const baseUrl = 'http://localhost:8080/ollama/chat'
                    const url = `${baseUrl}?prompt=${encodeURIComponent(userInput.value.trim())}`

                    eventSource2 = new EventSource(url)
                    isConnected.value = true

                    eventSource2.onmessage = (event) => {
                        const parsed = parseSSEData2(event.data)
                        messages2.value.push({
                            time: new Date().toLocaleTimeString(),
                            data: event.data,
                            parsed: parsed
                        })
                    }

                    eventSource2.onerror = (error) => {
                        console.error('SSE Error:', error)
                        disconnect2()
                    }
                } catch (error) {
                    console.error('Connection Error:', error)
                    disconnect2()
                }
            }

            // è¿æ¥æ–¹æ³•
            const connectAll = () => {
                if (!userInput.value.trim()) return alert('è¯·è¾“å…¥æ¶ˆæ¯')
                clearMessages()
                connect()
                connect2()
            }
            const disconnectAll = () => {
                disconnect()
                disconnect2()
            }

            const disconnect = () => {
                if (eventSource) {
                    eventSource.close()
                    eventSource = null
                }
                if (!eventSource && !eventSource2) {
                    isConnected.value = false
                }
            }

            const disconnect2 = () => {
                if (eventSource2) {
                    eventSource2.close()
                    eventSource2 = null
                }
                if (!eventSource && !eventSource2) {
                    isConnected.value = false
                }
            }

            const clearMessages = () => {
                messages.value = []
                messages2.value = []
            }

            return {
                userInput,
                messages,
                messages2,
                isConnected,
                connectAll,
                disconnectAll,
                clearMessages,
                reasoningChain,
                reasoningChain2,
                finalAnswer,
                finalAnswer2,
                reasoningRef,
                reasoningRef2,
                answerRef,
                answerRef2
            }
        }
    }).mount('#app')
</script>
</body>
</html>